from customprint import Logger
import numpy as np
import matplotlib.pyplot as plt

class Wind:
    def __init__(self):
        self.density = 1.293
        self.velocity = np.zeros(2)

class Wing:
    def __init__(self, heading):
        self.area = 15
        # heading is perpendicular to the surface of the wing, pointing forward
        self.heading = heading

class Boat:
    def __init__(self):
        self.mass = 100
        self.position = np.zeros(2)
        self.velocity = np.zeros(2)
        self.acceleration = np.zeros(2)
        self.heading = np.zeros(2)
        self.wing = Wing(self.heading)

# m_velocity -= m_velocity * m_linearDrag * a_timeStep;

# if (glm::length(m_velocity) < 0.001f)
# {
#     if (glm::length(m_velocity) < glm::length(a_gravity) * m_linearDrag * a_timeStep)
#     {
#         m_velocity = glm::vec2(0);
#     }
# }

# m_position += GetVelocity() * a_timeStep;
# ApplyForce(a_gravity * GetMass() * a_timeStep, glm::vec2(0));

class World:
    def __init__(self, wind: Wind, boat: Boat):
        self.gravity = 9.81
        self.wind = wind
        self.boat = boat
    
    def update(self, dt):
        # apply friction to the boat
        boat_weight = self.boat.mass * self.gravity
        damping_factor = 10 / boat_weight
        self.boat.velocity -= self.boat.velocity * damping_factor * dt

        if compute_magnitude(self.boat.velocity) < 0.01:
            self.boat.velocity = np.zeros(2)
        
        # apply wind force to the boat
        wind_force = compute_wind_force(self.wind, self.boat)

        self.boat.acceleration = compute_acceleration(wind_force, self.boat.mass)
        self.boat.velocity += (self.boat.acceleration * dt)
        self.boat.position += (self.boat.velocity * dt)

def compute_angle(vec):
    return np.arctan2(vec[1], vec[0])

def compute_magnitude(vec):
    return np.sqrt(vec[0]*vec[0] + vec[1]*vec[1])

def compute_acceleration(force, mass):
    return force / mass

# air_density [kg / m^3]
# wing_area [m^2]
# wind_velocity [(km/h, km/h)]
# computes the force generated by the wind on the wing of a boat
# the force is max when the wind is perpendicular to the wing, and 0 when it's parallel
# so multiply the force by a gain that is computed using the sin of the angle between the
# wing and the wind
def compute_wind_force(wind: Wind, boat: Boat):
    air_mass = wind.density * boat.wing.area
    gain = np.abs(np.sin(compute_angle(wind.velocity)))
    return air_mass * wind.velocity * gain

if __name__ == '__main__':
    wind = Wind()
    boat = Boat()
    world = World(wind, boat)

    velocities = []
    positions = []
    times = []

    dt = 0.5

    world.wind.velocity = np.array([15.0, 8.0])

    for time_elapsed in np.arange(0, 100, dt):
        if time_elapsed % 5 == 0 and  0 < time_elapsed < 10:
            world.wind.velocity = np.zeros(2)
        velocities.append(world.boat.velocity.copy())
        positions.append(world.boat.position.copy())
        times.append(time_elapsed)

        Logger.debug(f'Boat velocity: {world.boat.velocity}, Boat position: {world.boat.position}')
        
        world.update(dt)
        
    plt.plot(times, list(map(lambda p: p[0], velocities)))
    plt.plot(times, list(map(lambda p: p[1], velocities)))
    # plt.plot(times, list(map(lambda p: p[0] / 10, positions)))
    plt.show()